// define a variable to import the <Verifier> or <renamedVerifier> solidity contract generated by Zokrates

// Test verification with correct proof
// - use the contents from proof.json generated from zokrates steps

    
// Test verification with incorrect proof

// define a variable to import the <Verifier> or <renamedVerifier> solidity contract generated by Zokrates
const Verifier = artifacts.require("Verifier");
let proof = require("../../zokrates/code/square/proof.json");
// - use the contents from proof.json generated from zokrates steps

contract("TestSquareVerifier", async (accounts) => {

    var contractInstance;

    describe("Testing square verifier: ZK snarks", function () {
        beforeEach(async function() {
            contractInstance = await Verifier.deployed();
        });
        // Test verification with correct proof
        it("verifies with correct proof", async() => {
            //console.log(typeof(proof.proof.A_p));
            let verified = await contractInstance.verifyTx.call(
                proof.proof.a,
                proof.proof.b,
                proof.proof.c,
                proof.inputs
            );
            assert.equal(verified, true, "Proof could not be verified");
        });

        //Test verification with incorrect proof
        it("does not verify with incorrect proof", async() => {
            // let falsePair equal to the A_p property
            let falsePair = ["0x12baad06ae829ea52943352045db376000000000000000a", "0x8132fae6f08fcb476ae909020bb6ad975d36b000000000000"];
            let error = false
            try {
                await contractInstance.verifyTx.call(
                    falsePair,
                    proof.proof.b,
                    proof.proof.c,
                    proof.inputs
                );
            }
            catch (err) {
                error = true;
            }
            assert.equal(error, true, "Invalid Opcode should throw an error");
        });

    });
});